---
title: php基础算法
date: 2018-11-24 14:42:47
categories: PHP
tags:
	算法
---
**1.冒泡排序**

冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，依次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。

步骤：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。


具体代码：
```php
    $arr=array(1,43,54,62,21,66,32,78,36,76,39);
    function bubblesort($arr){
    	$len=count($arr);
    	//计算需要冒泡的轮次
    	for($i=1;$i<$len;$i++){
    		//这里的循环控制每轮两个数之间一共比较的次数，随着数字的减少，所以经历的轮数越多比较的次数越少
    		for($k=0;$k<$len-$i;$k++){//如果前一个数比后一位数大，就将两个数的位置互换，那么第一轮两两比较下来就能确定最大数了，以此类推
    			if($arr[$k]>$arr[$k+1]){
    				$tmp=$arr[$k+1];
    				$arr[$k+1]=$arr[$k];
    				$arr[$k]=$tmp;
    			}
    		}
    	}
    	return $arr;
    }
```
**2.选择排序**

选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。
```php
    //实现思路 双重循环完成，外层控制轮数，当前的最小值。内层 控制的比较次数
    function select_sort($arr) {
    	for($i=0,$len=count($arr);$i<$len-1;$i++){
    		//假设最小值为初始位置
    		$p=$i;
    		for($j=$i+1;$l<$len;$j++){
    			if($arr[$p]>$arr[$j]){
    				//比较发现更小的值，则记录最小值的位置，并在下次比较采用已知的最小值进行比较
    				$p=$j;
    			}
    		}
    		//那么第一轮比较下来就确定了最小值的位置
    		//这个时候再比较当前最小值的位置与当前轮次开始时最小值位置是否一致，如果不一致，则将两值的位置交换
    		if($p!=$i){
    			$tmp=$arr[$p];
    			$arr[$p]=$arr[$i];
    			$arr[$i]=$tmp;
    		}
    	}
    	return $arr;
    
    }
```
**3.插入排序**

插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

步骤：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置中
6. 重复步骤2

具体代码：
```php
    function insert_sort($arr) {
    	 $len=count($arr);
    	 for($i=1; $i<$len; $i++) {
    	 //获得当前需要比较的元素值。
    		 $tmp = $arr[$i];
    		 //内层循环控制 比较 并 插入
    		 for($j=$i-1; $j>=0; $j--) {
    		 //$arr[$i];//需要插入的元素; $arr[$j];//需要比较的元素
    			 if($tmp < $arr[$j]) {
    				 //发现插入的元素要小，交换位置
    				 //将后边的元素与前面的元素互换
    				 $arr[$j+1] = $arr[$j];
    				 //将前面的数设置为 当前需要交换的数
    				 $arr[$j] = $tmp;
    			 } else {
    				 //如果碰到不需要移动的元素
    				 //由于是已经排序好是数组，则前面的就不需要再次比较了。
    				 break;
    			 }
    		 }
    	 }
    	 //将这个元素 插入到已经排序好的序列内。
    	 //返回
    	 return $arr;
    }
```
**4.快速排序**
快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要Ο(n log n)次比较。在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log n) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来，且在大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方项之可能性。

步骤：
1. 从数列中挑出一个元素，称为 “基准”（pivot）
2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。
3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

具体代码：
```php
    function quick_sort($arr){
      //判断参数是否是一个数组
      if(!is_array($arr)) return false;
      //递归出口:数组长度为1，直接返回数组
      $length = count($arr);
      if($length<=1) return $arr;
      //数组元素有多个,则定义两个空数组
      $left = $right = array();
     //使用for循环进行遍历，把第一个元素当做比较的对象
     for($i=1; $i<$length; $i++){
    	 //判断当前元素的大小
    	 if($arr[$i]<$arr[0]){
    	 	$left[]=$arr[$i];
    	 }else{
    	 	$right[]=$arr[$i];
    	 }
     }
     //递归调用
     $left=quick_sort($left);
     $right=quick_sort($right);
     //将所有的结果合并
     return array_merge($left,array($arr[0]),$right);
    }
```
